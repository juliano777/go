# Tipos de Dados

## Tipos de dados primitivos

### Numéricos

#### Inteiros

Go fornece tipos inteiros com tamanhos fixos, além de tipos cujo tamanho
depende da arquitetura do sistema:  

- **Inteiros de tamanho fixo**  
  - **Com sinal**: `int8`, `int16`, `int32`, `int64`.  
  - **Sem sinal**: `uint8`, `uint16`, `uint32`, `uint64`.  

- **Inteiros dependentes da arquitetura**  
  - `int`: inteiro com sinal padrão, cujo tamanho pode ser 32 ou 64 bits
    conforme a arquitetura do processador.  
  - `uint`: inteiro sem sinal, que corresponde ao `int` no tamanho (32 ou 64
     bits).  
  - `uintptr`: inteiro sem sinal, grande o suficiente para armazenar o valor
     de um ponteiro.  

| Tipo | Tamanho (bits) | Sinal | Intervalo de valores | Uso comum / Aliases |
| :--- | :--- | :--- | :--- | :--- |
| **int8** | 8 | Sim | $-128$ a $127$ | Economia extrema de espaço. |
| **int16** | 16 | Sim | $-32.768$ a $32.767$ | |
| **int32** | 32 | Sim | $-2.147.483.648$ a $2.147.483.647$ | Alias: **`rune`** (usado para pontos de código Unicode). |
| **int64** | 64 | Sim | $\approx -9 \times 10^{18}$ a $\approx 9 \times 10^{18}$ | Necessário para números muito grandes. |
| **uint8** | 8 | Não | $0$ a $255$ | Alias: **`byte`** (usado para dados binários). |
| **uint16** | 16 | Não | $0$ a $65.535$ | |
| **uint32** | 32 | Não | $0$ a $4.294.967.295$ | |
| **uint64** | 64 | Não | $\approx 0$ a $\approx 18 \times 10^{18}$ | Necessário para números positivos muito grandes. |
| **int** | 32 ou 64 | Sim | Varia (depende da arquitetura) | **Tipo Padrão.** Usado para a maioria dos inteiros e para índices de *arrays*/*slices*. |
| **uint** | 32 ou 64 | Não | Varia (depende da arquitetura) | |
| **uintptr** | 32 ou 64 | Não | Varia (depende da arquitetura) | Usado para armazenar o valor numérico de um ponteiro. |

#### Ponto flutuante

Apenas `float32` e `float64` são disponibiizados como tipos de ponto flutuante em
Go.  
A diferença essencial entre eles está na precisão e tamanho que ocupam em
memória seguindo o padrão [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754).

| Tipo | Tamanho (bits) | Padrão IEEE-754 | Precisão (dígitos decimais) | Intervalo aproximado | Uso comum |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **float32** | 32 | Simples | $\approx 6$ a $7$ | $\approx \pm 1.4 \times 10^{-45}$ a $\pm 3.4 \times 10^{38}$ | Uso onde a precisão é menos crítica ou para economia de memória. |
| **float64** | 64 | Dupla | $\approx 15$ a $17$ | $\approx \pm 4.9 \times 10^{-324}$ a $\pm 1.8 \times 10^{308}$ | **Tipo Padrão.** Usado para a maioria dos cálculos que exigem alta precisão. |

### Tipos de texto

Representam informação textual.
O tipo `string` é usado para sequências de zero ou mais caracteres, cujos
valores devem ser definidos entre aspas (`"exemplo"`).  
É importante mencionar que Go também usa o tipo `rune` (alias para `int32`),
definido entre apóstrofos (`'X'`), para representar um **único caractere**
(ponto de código Unicode).

#### String

Em Go uma _string_ comum utiliza-se o tipo de dado `string`, que tem as
seguintes características:  

- **Imutabilidade**  
  Após a criação de uma _string_ seu conteúdo não pode ser alterado. E
  qualquer operação que pareça alterá-la, na verdade está criando uma nova.

- **UTF-8**  
  Em Go _strings_ são tratadas como sequências de bytes que representam um
  texto UTF-8. Assim permitindo que lidem eficientemente com caracteres de
  qualquer idioma.

- **Tipagem**  
  O tipo de dado `string` é um tipo embutido. O comprimento da _string_ (em
  bytes) é armazenado com os próprios dados. Ou seja, `string` não armazena
  apenas o texto, mas sim uma pequena estrutura de dados (_string header_),
  cujos elementos são:
  1. **Um ponteiro**  
    O endereço de memória onde a sequência real de bytes do texto está
    gravada;
  2. **Comprimento (length)**  
    Um número inteiro que indica quantos bytes essa sequência de texto possui.

- **Acesso a elementos**  
  - É possível acessar bytes individuais. usando a notação de índice (`s[i]`),
    que retorna o byte na posição `i`.   
  - Para iterar sobre cada elemento é possível fazê-lo utilizando `for range`.


#### Rune

Como dito anteriormente, rune na verdade é um _alias_ para `int32`.  
Mas por que um inteiro de 32 bits?  
Isso é para ter suporte a caracteres Unicode, que atualmente define mais de
140 mil caracteres, indo de `U+0000` a `U+10FFFF`, sendo assim necessário um
tipo de 32 bits.  

No seguinte exemplo de código há algumas coisas interessantes que serão
comentadas conforme sua saída:
```go
package main

import "fmt"

// Varuáveis rune
var myRune1 rune = 'x'  // rune: inteiro de 32 bits
var myRune2 uint8 = 'y'  // unsigned int de 8 bits

// Constante template de mensagem
const msg = "Valor do caractere: %c, Tipo: %T, Inteiro: %d\n"

func main() {
	fmt.Printf(msg, myRune1, myRune1, myRune1)
	fmt.Printf(msg, myRune2, myRune2, myRune2)
}
```
```
Valor do caractere: x, Tipo: int32, Inteiro: 120
Valor do caractere: y, Tipo: uint8, Inteiro: 121
```

Na definição das variáveis, a primeira foi definida como `rune` e a segunda
como `uint8`.   
Na saída foram impressas mensagens em tela conforme os dados da variável,
sendo a primeira o próprio caractere, em seguida seu tipo e seu respectivo
valor como inteiro.  
Observa-se também que ambos os caracteres apresentados (`x` e `y`) estão
dentro do conjunto de caracteres [ASCII](https://en.wikipedia.org/wiki/ASCII),
cujos valores variam de `0` a `127`. Assim sendo possivel utilizar um tipo
inteiro pequeno como um inteiro de 8 bits.   
O tipo `uint8` em Go é geralmente usado para representar um **byte** (`byte`
_alias_ para `uint8`), que é suficiente para todos caracteres ASCII.  
Em casos onde somente caracteres ASCII são necessários é muito melhor utilizar
`byte` como tipo de dado por questões de performance e memória.  

#### Formatação de texto

A formatação de _strings_ em Go é feita por meio de **verbos de formatação**,
que são códigos especiais usados funções de formatação (tais como `fmt.Printf`
e `fmt.Sprintf`). Com esse recurso pode-se modelar a forma da representação de
texto.   
Segundo diz a [documentação oficial](https://pkg.go.dev/fmt), o pacote `fmt`
implementa funções de entrada e saída análogas às funções `printf` e `scanf`,
que são derivadas de C, porém mais siimples.  
  
**Verbos de formatação**  
  
| Verbo | Tipo de dado aplicável | Descrição | Exemplo |
| :--- | :--- | :--- | :--- |
| **`%v`** | Qualquer | O valor no formato padrão (default). | `fmt.Printf("%v", 100)` -> `100` |
| **`%#v`**| Qualquer | A representação do valor em sintaxe Go. Útil para structs e debugging. | `fmt.Printf("%#v", 1)` -> `1` |
| **`%T`** | Qualquer | **O tipo** do valor. | `fmt.Printf("%T", 1)` -> `int` |
| --- | --- | --- | --- |
| **`%d`** | Inteiro | O valor em base 10 (decimal). | `fmt.Printf("%d", 15)` -> `15` |
| **`%s`** | String | A string simples. | `fmt.Printf("%s", "hello")` -> `hello` |
| **`%q`** | String/Rune | Uma string ou caractere entre aspas duplas (`"`), com escape de caracteres. | `fmt.Printf("%q", "hi")` -> `"hi"` |
| **`%t`** | Booleano | O valor booleano (`true` ou `false`). | `fmt.Printf("%t", true)` -> `true` |
| **`%c`** | Inteiro | O **caractere** correspondente ao ponto de código Unicode. | `fmt.Printf("%c", 65)` -> `A` |
| **`%f`** | Ponto Flutuante | Notação decimal (ponto flutuante), sem expoente. | `fmt.Printf("%f", 3.14)` -> `3.140000` |
| **`%p`** | Ponteiro | O valor do ponteiro em notação hexadecimal. | `fmt.Printf("%p", &var)` -> `0x...` |
| **`%%`** | N/A | Um sinal de percentual (`%`) literal. | `fmt.Printf("100%%")` -> `100%` |


### Lógicos

Em Go o tipo `bool`é utilizado para valores "booleanos", o qual só aceita dois
valores: `true` (verdadeiro) e `false` (falso).  
O tipo `bool` é a base para as estruturas de controle de fluxo como `if`,
`else` e `for`.

```go
package main

import "fmt"

var isDone bool = false

func main() {
	if isDone {
		fmt.Println("It is done!")
	} else {
		fmt.Println("It is NOT done!")
	}
}
```
```
It is NOT done!
```

## Tipos de dados compostos (estruturados)

### Arrays (vetores)

### Estrutura / registro (struct/objeto)

###