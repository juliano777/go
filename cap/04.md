# Tipos de Dados

## Tipos de dados primitivos

### Numéricos

#### Inteiros

Go fornece tipos inteiros com tamanhos fixos, além de tipos cujo tamanho
depende da arquitetura do sistema:  

- **Inteiros de tamanho fixo**  
  - **Com sinal**: `int8`, `int16`, `int32`, `int64`.  
  - **Sem sinal**: `uint8`, `uint16`, `uint32`, `uint64`.  

- **Inteiros dependentes da arquitetura**  
  - `int`: inteiro com sinal padrão, cujo tamanho pode ser 32 ou 64 bits
    conforme a arquitetura do processador.  
  - `uint`: inteiro sem sinal, que corresponde ao `int` no tamanho (32 ou 64
     bits).  
  - `uintptr`: inteiro sem sinal, grande o suficiente para armazenar o valor
     de um ponteiro.  

| Tipo | Tamanho (bits) | Sinal | Intervalo de valores | Uso comum / Aliases |
| :--- | :--- | :--- | :--- | :--- |
| **int8** | 8 | Sim | $-128$ a $127$ | Economia extrema de espaço. |
| **int16** | 16 | Sim | $-32.768$ a $32.767$ | |
| **int32** | 32 | Sim | $-2.147.483.648$ a $2.147.483.647$ | Alias: **`rune`** (usado para pontos de código Unicode). |
| **int64** | 64 | Sim | $\approx -9 \times 10^{18}$ a $\approx 9 \times 10^{18}$ | Necessário para números muito grandes. |
| **uint8** | 8 | Não | $0$ a $255$ | Alias: **`byte`** (usado para dados binários). |
| **uint16** | 16 | Não | $0$ a $65.535$ | |
| **uint32** | 32 | Não | $0$ a $4.294.967.295$ | |
| **uint64** | 64 | Não | $\approx 0$ a $\approx 18 \times 10^{18}$ | Necessário para números positivos muito grandes. |
| **int** | 32 ou 64 | Sim | Varia (depende da arquitetura) | **Tipo Padrão.** Usado para a maioria dos inteiros e para índices de *arrays*/*slices*. |
| **uint** | 32 ou 64 | Não | Varia (depende da arquitetura) | |
| **uintptr** | 32 ou 64 | Não | Varia (depende da arquitetura) | Usado para armazenar o valor numérico de um ponteiro. |

#### Ponto flutuante

Apenas `float32` e `float64` são disponibiizados como tipos de ponto flutuante em
Go.  
A diferença essencial entre eles está na precisão e tamanho que ocupam em
memória seguindo o padrão [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754).

| Tipo | Tamanho (bits) | Padrão IEEE-754 | Precisão (dígitos decimais) | Intervalo aproximado | Uso comum |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **float32** | 32 | Simples | $\approx 6$ a $7$ | $\approx \pm 1.4 \times 10^{-45}$ a $\pm 3.4 \times 10^{38}$ | Uso onde a precisão é menos crítica ou para economia de memória. |
| **float64** | 64 | Dupla | $\approx 15$ a $17$ | $\approx \pm 4.9 \times 10^{-324}$ a $\pm 1.8 \times 10^{308}$ | **Tipo Padrão.** Usado para a maioria dos cálculos que exigem alta precisão. |

### Tipos de texto

Representam informação textual.
O tipo `string` é usado para sequências de zero ou mais caracteres, cujos
valores devem ser definidos entre aspas (`"exemplo"`).  
É importante mencionar que Go também usa o tipo `rune` (alias para `int32`),
definido entre apóstrofos (`'X'`), para representar um **único caractere**
(ponto de código Unicode).

#### String

Em Go uma _string_ comum utiliza-se o tipo de dado `string`, que tem as
seguintes características:  

- **Imutabilidade**  
  Após a criação de uma _string_ seu conteúdo não pode ser alterado. E
  qualquer operação que pareça alterá-la, na verdade está criando uma nova.

- **UTF-8**  
  Em Go _strings_ são tratadas como sequências de bytes que representam um
  texto UTF-8. Assim permitindo que lidem eficientemente com caracteres de
  qualquer idioma.

- **Tipagem**  
  O tipo de dado `string` é um tipo embutido. O comprimento da _string_ (em
  bytes) é armazenado com os próprios dados. Ou seja, `string` não armazena
  apenas o texto, mas sim uma pequena estrutura de dados (_string header_),
  cujos elementos são:
  1. **Um ponteiro**  
    O endereço de memória onde a sequência real de bytes do texto está
    gravada;
  2. **Comprimento (length)**  
    Um número inteiro que indica quantos bytes essa sequência de texto possui.

- **Acesso a elementos**  
  - É possível acessar bytes individuais. usando a notação de índice (`s[i]`),
    que retorna o byte na posição `i`.   
  - Para iterar sobre cada elemento é possível fazê-lo utilizando `for range`.


#### Rune

Como dito anteriormente, rune na verdade é um _alias_ para `int32`.  
Mas por que um inteiro de 32 bits?  
Isso é para ter suporte a caracteres Unicode, que atualmente define mais de
140 mil caracteres, indo de `U+0000` a `U+10FFFF`, sendo assim necessário um
tipo de 32 bits.  

No seguinte exemplo de código há algumas coisas interessantes que serão
comentadas conforme sua saída:
```go
package main

import "fmt"

// Varuáveis rune
var myRune1 rune = 'x'  // rune: inteiro de 32 bits
var myRune2 uint8 = 'y'  // unsigned int de 8 bits

// Constante template de mensagem
const msg = "Valor do caractere: %c, Tipo: %T, Inteiro: %d\n"

func main() {
	fmt.Printf(msg, myRune1, myRune1, myRune1)
	fmt.Printf(msg, myRune2, myRune2, myRune2)
}
```
```
Valor do caractere: x, Tipo: int32, Inteiro: 120
Valor do caractere: y, Tipo: uint8, Inteiro: 121
```

Na definição das variáveis, a primeira foi definida como `rune` e a segunda
como `uint8`.   
Na saída foram impressas mensagens em tela conforme os dados da variável,
sendo a primeira o próprio caractere, em seguida seu tipo e seu respectivo
valor como inteiro.  
Observa-se também que ambos os caracteres apresentados (`x` e `y`) estão
dentro do conjunto de caracteres [ASCII](https://en.wikipedia.org/wiki/ASCII),
cujos valores variam de `0` a `127`. Assim sendo possivel utilizar um tipo
inteiro pequeno como um inteiro de 8 bits.   
O tipo `uint8` em Go é geralmente usado para representar um **byte** (`byte`
_alias_ para `uint8`), que é suficiente para todos caracteres ASCII.  
Em casos onde somente caracteres ASCII são necessários é muito melhor utilizar
`byte` como tipo de dado por questões de performance e memória.  

#### Formatação de texto

A formatação de _strings_ em Go é feita por meio de **verbos de formatação**,
que são códigos especiais usados funções de formatação (tais como `fmt.Printf`
e `fmt.Sprintf`). Com esse recurso pode-se modelar a forma da representação de
texto.   
Segundo diz a [documentação oficial](https://pkg.go.dev/fmt), o pacote `fmt`
implementa funções de entrada e saída análogas às funções `printf` e `scanf`,
que são derivadas de C, porém mais siimples.  
  
**Verbos de formatação**  
  
| Verbo | Tipo de dado aplicável | Descrição | Exemplo |
| :--- | :--- | :--- | :--- |
| **`%v`** | Qualquer | O valor no formato padrão (default). | `fmt.Printf("%v", 100)` -> `100` |
| **`%#v`**| Qualquer | A representação do valor em sintaxe Go. Útil para structs e debugging. | `fmt.Printf("%#v", 1)` -> `1` |
| **`%T`** | Qualquer | **O tipo** do valor. | `fmt.Printf("%T", 1)` -> `int` |
| --- | --- | --- | --- |
| **`%d`** | Inteiro | O valor em base 10 (decimal). | `fmt.Printf("%d", 15)` -> `15` |
| **`%s`** | String | A string simples. | `fmt.Printf("%s", "hello")` -> `hello` |
| **`%q`** | String/Rune | Uma string ou caractere entre aspas duplas (`"`), com escape de caracteres. | `fmt.Printf("%q", "hi")` -> `"hi"` |
| **`%t`** | Booleano | O valor booleano (`true` ou `false`). | `fmt.Printf("%t", true)` -> `true` |
| **`%c`** | Inteiro | O **caractere** correspondente ao ponto de código Unicode. | `fmt.Printf("%c", 65)` -> `A` |
| **`%f`** | Ponto Flutuante | Notação decimal (ponto flutuante), sem expoente. | `fmt.Printf("%f", 3.14)` -> `3.140000` |
| **`%p`** | Ponteiro | O valor do ponteiro em notação hexadecimal. | `fmt.Printf("%p", &var)` -> `0x...` |
| **`%%`** | N/A | Um sinal de percentual (`%`) literal. | `fmt.Printf("100%%")` -> `100%` |


### Lógicos

Em Go o tipo `bool`é utilizado para valores "booleanos", o qual só aceita dois
valores: `true` (verdadeiro) e `false` (falso).  
O tipo `bool` é a base para as estruturas de controle de fluxo como `if`,
`else` e `for`.

```go
package main

import "fmt"

var isDone bool = false

func main() {
	if isDone {
		fmt.Println("It is done!")
	} else {
		fmt.Println("It is NOT done!")
	}
}
```
```
It is NOT done!
```

## Tipos de dados compostos (estruturados)

### Arrays (vetores)

São estruturas que armazenam uma sequência de elementos **do mesmo tipo** em
um número fixo de posições.  
Com relação aos valores padrão (valor zero), quando os valores não forem
inicializados explicitamente, os membros terão seu valor de acordo com o tipo.
Por exemplo, `0` para `int`, `""` para `string`, `false` para `bool`.  
Os valores de um array só podem ser definidos dentro de uma função.
Seu tamanho é determinado no momento da criação de forma explícita ou
implícita e não pode ser alterado durante a execução. O tamanho faz parte do
tipo do array.  

Exemplo: `[3]int` e `[4]int` são tipos de arrays diferentes.  

```go
package main

import "fmt"

// Array de 5 inteiros.
var array1 [5]int

// Array inicializado explicitamente.
var array2 = [3]string{"a", "b", "c"}

// O compilador infere o tamanho.
var array3 = []float64{1.0, 2.5, 3.14}

func main() {
	// Definir valores de elementos de array1
	array1[0] = 73
	array1[3] = 21

	// Imprimir valores dos arrays
	fmt.Println(array1)
	fmt.Println(array2)
	fmt.Println(array3)
}

```
```
[73 0 0 21 0]
[a b c]
[1 2.5 3.14]
```

### Slices

_Slice_ é o tipo de estrutura de dados mais utilizada em Go devido a ser mais
flexíveis e poderoso do que arrays.  
Slices são referências dinâmicas a um array subjacente.  
Seu tamanho é variável, diferente de _arrays_.  
Um _slice_ não armazena dados, em vez disso ele aponta para uma seção contígua
de um _array_ existente, assim vários _slices_ podem compartilhar o mesmo
_array_ subjacente; **referência a _array_**.

Basicamente um _slice_ é uma estrutura de dados de três itens:

1. Um **ponteiro** para o elemento inicial (zero) do _array_ subjacente;
2. O **tamanho** (_length_) do _slice_: a quantidade de elementos que possui;
3. A **capacidade** (_capacity_): número de elementos do _array_ subjacente, começando no elemento apontado pelo _slice_.

#### Criação de slides

Há três maneiras principais para criar _slices_:

**1. Função `make()`**   

É a forma mais recomendada para criar um _slice_ vazio com um tamanho inicial,
assim garante que o _array_ subjacente seja alocado.

```go
// Sintaxe: make([]tipo, length, capacity)

// Slice de inteiros com 5 elementos (length) e capacidade 5.
meuSlice := make([]int, 5) 
// meuSlice é [0 0 0 0 0]

// Slice de strings com 0 elementos (length) mas capacidade 10.
// Pronto para armazenar até 10 elementos antes de realocar.
outrosSlice := make([]string, 0, 10) 
// outrosSlice é []
```

**2. Literal de slice**   

Assim como o literal de _array_, mas sem especificar o tamanho entre colchetes
(`[]`).

```go
// O compilador cria e inicializa o array subjacente.
cores := []string{"vermelho", "verde", "azul"} 
// cores é ["vermelho" "verde" "azul"], length=3, capacity=3
```

**3. Fatiando (slicing) um array ou outro slice**   

Pode-se criar um novo _slice_ tomando uma seção de um _array_ ou de um _slice_
existente.

```go
array := [5]int{1, 2, 3, 4, 5}

// Cria um slice que inclui os elementos do índice 1 até o (4-1)=3.
sliceDeArray := array[1:4] 
// sliceDeArray é [2 3 4], length=3, capacity=4 (elementos 2, 3, 4, 5)

// Cria um novo slice a partir do sliceDeArray
subSlice := sliceDeArray[0:2] 
// subSlice é [2 3], length=2, capacity=4
```

> Obs.: Modificar `subSlice`(ou `sliceDeArray`) modificará o _array_ original,
> pois compartilham o mesmo `array` subjacente.


### Estrutura / registro (struct/objeto)

###