# Particularidades da linguagem

## Sintaxe geral

A sintaxe de Go é simples, inspirada em C, porém mais enxuta.  
Blocos usam chaves (`{}`) sem ponto e vírgula (`;`) na maioria dos casos.
O compilador insere `;` automaticamente ao fim de certas linhas.  
Diferente de Python, a indentação não tem significado semântico.  

## Convenções de nomenclatura

- `camelCase` para itens internos;
- `PascalCase` para itens exportados;
- Preferência por nomes curtos e diretos;
- `ALL_CAPS`, diferente do que se vê em outras linguagens, não se usa para
constantes;
- Pacotes devem ter nomes curtos, preferencialmente em letras minúsculas.

### Comentários

Como em outras linguagens, Go também faz uso de comentários para que
programadores, como mandam a boas práticas, comentar o código para futuras
manutenções ou revisões.  
Para comentários de linha única utiliza-se barras duplas (`//`).  
Para mais de uma linha barra e asterisco para o início (`/*`) e no fim
asterisco barra (`*/`).


**Linha única**
```go
// Comentário de linha única
```

**Múltiplas linhas**
```go
/*
Eis aqui um comentário para mais de uma linha.
Pode ser útil em diversas situações onde algo sucinto não é suficiente para
explicar o que o trecho do código faz.
*/
```

### Palavras reservadas (Keywords)

As seguintes palavras são reservadas e não podem ser usadas como identificadores:

```
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
```

### Operadores e pontuação

Abaixo representações de operadores (incluindo operadores de assimilação) e pontuação:

```
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
*    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=          ~
```

### Estrutura mínima de um código Go para o tradicional "Hello, World"

O mínimo necessário em código em Go para apenas imprimir uma mensagem tela:

```go
package main

import "fmt"

func main(){
    fmt.Println("Hello, World!")
}
```

O mesmo código com comentários para ajudar no entendimento:

```go
/*
A linha "package main" declara que este arquivo é um executável.
Todo executável Go precisa ter a função "main()"para iniciar a execução e essa
função deve pertencer ao pacote "main".
*/
package main

/*
Instrução para incluir a biblioteca "fmt"(format).
Essa biblioteca contém funções para I/O (entrada e saída), como a que será
usada para imprimir a mensagem em tela (Println).
*/
import "fmt"

/*
Função main()
É o ponto de partida de qualquer programa Go, que a partir da execução dessa
função começa a execução do programa.
*/
func main(){
    // Função "Println" da biblioteca "fmt", para imprimir mensagem em tela.
    fmt.Println("Hello, World!")
}
```

### Variáveis e atribuições de valores

Existem 3 (três) formas para criação e atribuição de variáveis em Go, conforme
o contexto e da necessidade de inicialização.

**1. Declaração completa - `var` com tipo e valor inicial**  

Forma mais explícita e tradicional.  
Obrigatória quando se deseja declarar uma variável sem atribuir um valor
inicial, caso em que ela receberá um **valor zero** (*zero value*), que é um
valor padrão conforme o tipo de dado.

Declaração sem inicialização:

```go
var age int  // valor padrão zero
var name string  // Valor padrão "" (string vazia)
```

Declaração com inicialização:

```go
var age int = 20
var name string = "Mary"
```

Omitindo o tipo (faz com que Go infira o tipo pelo valor inicial):

```go
var price = 9.99
var active = true
```

**2. Declaração curta duração (_short variable declaration_)**

É o jeito mais comum de declarar e inicializar variáveis
**dentro de funções**. Então Go infere o tipo de forma automática e
**não pode usá-la sem atribuir um valor inicial**. Só pode ser usada para
declarar **variáveis locais** (escopo de função).

```go
number := 37  // Go infere int
result := "OK"  // Go infere string
```

**3. Atribuição simples (reatribuição)**

```go
var x int = 5  // Declaração inicial (exemplo com var)
x = 10  // Reatribuição de valor

y := "Go"  // Declaração inicial (ex. com :=)
y = "Golang"  // Reatribuição do valor
```

#### Resumo de variáveis

| Método | Uso Principal | Obriga Inicialização? | Onde Usar? |
| :--- | :--- | :--- | :--- |
| **`var ...`** | Declaração sem valor inicial (zero value), ou quando o tipo precisa ser explícito. | Não (recebe zero value) | Variáveis globais e locais. |
| **`:=`** | Declaração e inicialização concisa. | Sim | **Apenas** variáveis locais (dentro de funções). |
| **`=`** | **Reatribuir** um valor. | N/A (Variável deve existir) | Variáveis globais e locais. |

### Constantes

São valores nomeados cuja declaração após feita não pode ser alterada.  
Constantes são definidas em tempo de compilação, o que lhes diferencia de
variáveis.  
A declaração é feita pela palavra-chave `const`.

```go
const x = 3.7  // Constante numérica não tipada
const y int = 9  // Constante inteira tipada
const z = "foo"  // Constante string
```

| Característica | Constante (`const`) | Variável (`var` ou `:=`) |
| :--- | :--- | :--- |
| **Mutabilidade** | **Imutável**. O valor não pode ser alterado após a declaração. | **Mutável**. O valor pode ser alterado (re-atribuído) durante a execução do programa. |
| **Tempo de Definição** | Em **tempo de compilação** (compile-time). | Em **tempo de execução** (runtime). |
| **Tipos Permitidos** | Apenas tipos de valor básicos: `bool`, `string`, e tipos numéricos (inteiros, `float`, `complex`). | Todos os tipos de Go: básicos, compostos (`struct`, `array`, `slice`, `map`, etc.), e interfaces. |
| **Declaração Curta** | **Não** pode usar a sintaxe curta `:=`. | **Pode** usar a sintaxe curta `:=` dentro de funções. |
| **Memória** | Não ocupam espaço de memória em tempo de execução como as variáveis. São substituídas diretamente em tempo de compilação. | Ocupam espaço de memória (endereço) em tempo de execução para armazenar seu valor. |

#### Vantagens de constantes

- **Imutabilidade (segurança)**  
    Impede que o valor seja alterado acidentalmente em qualquer parte do
    código. Ideal para valores que nunca devem mudar.  

- **Desempenho**  
    Devido à definição em tempo de compilação é possível ter otimizações, como
    a substituição direta do nome da constante pelo seu valor (_inlining_), o
    que pode levar a um código mais rápido do que usar uma variável.  

- **Constantes não tipadas (_untyoped_)**  
    Constantes numéricas podem ser não tipadas (exceto se for especificado um
    tipo explicitamente). Isso permite que uma única constante numérica seja
    usada em expressões de tenham tipos numéricos diferentes (`int`, `int32`,
    `float64`) sem precisar converter explicitamente.  

- **Precisão arbitrária**  
    Constantes numéricas não tipadas podem ter precisão arbitrária em tempo de
    compilação, ou seja, elas não são limitadas pelo tamanho de um `int` ou
    `float64`até que sejam usadas em um contexto tipado.  

#### Desvantagens de constantes

- **Limitação de tipos**  
    Sua principal desvantagem é a restrição de tipos. Ou seja, não é possível
    declarar constantes de tipos mais complexos, como _slices_, _maps_ ou
    _structs_.  

- **Limitação de expressões**  
    Uma constante deve ser inicializada com um valor que possa ser determinado
    em tempo de compilação. Não se pode usar chamadas de função ou expressões
    que dependam de resultados de tempo de execução para definir uma
    constante.  

- **Ausência de escopo variável**  
    Não é possível declarar constantes dentro de _loops_ ou blocos
    condicionais de forma tão flexível como variáveis locais, devido ao seu
    valor ser conhecido estaticamente (embora possam ser declaradas dentro de
    funções, no escopo da função ou no nível do pacote).

### Valores nil

Para quem vem de outras linguagens, `nil` pode ser interpretado como valor
nulo, o que é parcialmente verdade.  
Em Go `nil` é um identificador pré-declarado que representa a ausência de
valor ou o **valor zero (_zero value_)** para tipos específicos. É importante
observar que `nil` não é um tipo de dado por si só e não pode ser atribuído a
qualquer tipo.

Tipos que podem ter o valor `nil` são:

- Ponteiro (`*T`): não aponta para um valor;  
- Interface: não contém um valor concreto nem um tipo;    
- Map: é nulo (não iniciado ou sem dados);
- Slice: é nulo (não aponta para um _array_ subjacente);
- Canal (`chan T`): é nulo (não foi inicializado);
- Função (valor de função): é nulo.

### Zero values

Em Go **_zero values_** são valores padrão de acordo com um tipo de dado.  
Esses valores são atribuídos automaticamente ao declarar uma variável sem
atribuir um valor a ela explicitamente.  
Essa característica garante que toda variável tenha um valor bem definido,
evitando bugs comunsem outras linguagens que poderiam deixar variáveis não
inicializadas em um estado imprevisível (como lixo de memória).

| Tipo em Go | Zero Value | Exemplo de Zero Value | Declaração (Sem Inicialização Explícita) |
| :--- | :--- | :--- | :--- |
| **Inteiros** (`int`, `int32`, `uint`, etc.) | 0 | 0 | `var idade int` |
| **Ponto Flutuante** (`float32`, `float64`) | 0.0 | 0.0 | `var preco float64` |
| **Booleano** (`bool`) | `false` | `false` | `var ativo bool` |
| **String** (`string`) | String vazia | `""` | `var nome string` |
| **Ponteiro** (`*T`) | `nil` | `nil` | `var p *int` |
| **Slice** (`[]T`) | `nil` | `nil` | `var lista []string` |
| **Map** (`map[K]V`) | `nil` | `nil` | `var cache map[string]int` |
| **Channel** (`chan T`) | `nil` | `nil` | `var dados chan int` |
| **Interface** (`interface{}`) | `nil` | `nil` | `var err error` |